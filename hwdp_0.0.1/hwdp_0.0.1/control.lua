---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by obygi.
--- DateTime: 24.05.2024 00:39
---
---
---
require("lib_traverse")
require("lib_gui")
require("lib_buildings")

BUILDING_NOT_RESEARCHED = "building not researched, you fag!"

local function check_if_entity_prototype_maps_to_recipe(name)
    return not string.find(name, "-grounded") and not string.find(name, "-spaced")
end

local function initialize_global(player)
    global.players[player.index] = {}
    global.players[player.index].controls_active = true
    global.players[player.index].selected_ips = nil
    global.players[player.index].selected_recipe = nil
    global.players[player.index].recipes_buildings = nil
    global.players[player.index].byproducts = nil
    global.players[player.index].raw_resources = nil
    global.players[player.index].unlocked_productivity_modules = {}
    global.players[player.index].unlocked_speed_modules = {}
    global.players[player.index].unlocked_beacons = {}
    global.players[player.index].max_productivity_module = nil
    global.players[player.index].max_speed_module = nil
    global.players[player.index].max_beacon = nil
    global.players[player.index].crafting_category_building_map = {}
    global.players[player.index].crafting_category_selected_building = {}
end

script.on_init(function()
    global.players = {}
    for _, player in pairs(game.players) do
        initialize_global(player)
    end
end)

script.on_event(defines.events.on_player_created, function(event)
    local player = game.get_player(event.player_index)
    initialize_global(player)
end)

script.on_event(defines.events.on_player_removed, function(event)
    global.players[event.player_index] = nil
end)

script.on_event(defines.events.on_gui_selection_state_changed, function(event)
    local player = game.get_player(event.player_index)
    local selected_index = event.element.selected_index
    local item = event.element.items[selected_index]
    if event.element.name == "productivity_modules" then
        global.players[player.index].max_productivity_module = item
    elseif event.element.name == "speed_modules" then
        global.players[player.index].max_speed_module = item
    elseif event.element.name == "beacons" then
        global.players[player.index].max_beacon = item
    else
        -- buildings
        global.players[player.index].crafting_category_selected_building[event.element.name] = item
    end
end)

script.on_event("toggle_interface", function(event)
    -- Basically an entrypoint to the calculator. Consider moving setup to a separate function.
    local player = game.get_player(event.player_index)
    local prod = get_unlocked_productivity_modules(player)
    local speed = get_unlocked_speed_modules(player)
    local beacons = get_unlocked_beacons(player)
    local crafting_to_buildings_map = create_crafting_category_to_buildings_map(player)

    for category, buildings in pairs(crafting_to_buildings_map) do
        global.players[player.index].crafting_category_selected_building[category] = buildings[#buildings]
    end

    global.players[player.index].unlocked_productivity_modules = prod
    global.players[player.index].unlocked_speed_modules = speed
    global.players[player.index].unlocked_beacons = beacons
    global.players[player.index].crafting_category_building_map = crafting_to_buildings_map
    toggle_interface(player)
end)

script.on_event(defines.events.on_gui_closed, function(event)
    if event.element and event.element.name == "main_frame" then
        local player = game.get_player(event.player_index)
        toggle_interface(player)
    end
end)

script.on_event(defines.events.on_gui_click, function(event)
    if event.element.name == "run_recipes" then
        local player = game.get_player(event.player_index)
        local controls_flow = player.gui.screen.main_frame.content_frame.controls_flow
        local recipe_name = controls_flow.choose_recipe.elem_value
        local recipe_ips = controls_flow.ips_textfield.text

        -- persist search in global table and clear results
        global.players[player.index].selected_recipe = recipe_name
        global.players[player.index].selected_ips = recipe_ips
        global.players[player.index].recipes_buildings = nil
        global.players[player.index].byproducts = nil
        global.players[player.index].raw_resources = nil

        local raw_resources_per_second = {}
        local recipes_summary = {}
        local recipes_buildings = {}
        local byproducts = {}

        -- now retrieve recipe
        local recipe = player.force.recipes[recipe_name]
        traverse(
                player.force.recipes,
                recipe,
                recipe_ips,
                recipes_summary,
                raw_resources_per_second,
                byproducts,
                0,
                1
        )

        -- get building type per crafting category
        local crafting_category_building_map = {}
        for _, recipe_summary in pairs(recipes_summary) do
            local crafting_category = recipe_summary["crafting_category"]
            if crafting_category_building_map[crafting_category] == nil then
                local max_building_speed = -1
                local n_modules = -1
                for _, entity in pairs(game.get_filtered_entity_prototypes { { filter = "crafting-category", crafting_category = crafting_category } }) do
                    if check_if_entity_prototype_maps_to_recipe(entity.name) and player.force.recipes[entity.name].enabled == true and entity.crafting_speed > max_building_speed or (entity.crafting_speed == max_building_speed and entity.module_inventory_size > n_modules) then
                        max_building_speed = entity.crafting_speed
                        crafting_category_building_map[crafting_category] = entity
                        n_modules = entity.module_inventory_size
                    end
                end
            end
        end

        -- get recipes for productivity module
        local productivity_recipes = {}
        for _, rec_name in pairs(game.item_prototypes["productivity-module"].limitations) do
            productivity_recipes[rec_name] = true
        end

        -- get the highest unlocked modules
        local best_prod_module
        local best_productivity = 0
        local best_speed_module
        local best_speed_bonus = 0
        local beacon_slots=-1
        log("listing modules:")
        for _, rec in pairs(game.get_filtered_recipe_prototypes { { filter = "subgroup", subgroup = "module"} }) do
            log("#################")
            log("module name: " .. rec.name)
            if player.force.recipes[rec.name].enabled == true then
                local module = game.item_prototypes[rec.name]
                if module.module_effects ~= nil then
                    if string.find(rec.name, "productivity") and module.module_effects.productivity.bonus > best_productivity then
                        best_productivity = module.module_effects.productivity.bonus
                        best_prod_module = module
                        log("highest prod bonus: " .. best_productivity)
                        log("highest prod module name: " .. best_prod_module.name)
                    end
                    if string.find(rec.name, "speed") and module.module_effects.speed.bonus > best_speed_bonus then
                        best_speed_bonus = module.module_effects.speed.bonus
                        best_speed_module = module
                        log("highest speed bonus: " .. best_speed_bonus)
                        log("highest speed module name: " .. best_speed_module.name)
                    end
                else
                    -- it's a beacon!
                    log("beacon lol!")
                    local prot = game.entity_prototypes[rec.name]
                    beacon_slots = prot.module_inventory_size
                end
            end
            log("#################")

        end

        -- get number of buildings
        for rec_name, recipe_summary in pairs(recipes_summary) do
            -- building can be nil if it hasn't been unlocked yet
            local building = crafting_category_building_map[recipe_summary.crafting_category]

            if building == nil then
                -- building not researched yet
                recipes_buildings[rec_name] = { n_buildings = 0, building = BUILDING_NOT_RESEARCHED,
                                                items_per_second = recipe_summary.ips }
            else
                -- calculate how many buildings are needed to produce that recipe at desired throughput
                local r = game.recipe_prototypes[rec_name]
                local main_product = get_main_product(r)
                local productivity_bonus = 1
                local speed_bonus = 1

                if productivity_recipes[rec_name] ~= nil and best_prod_module ~= nil then
                    -- possible to use productivity modules
                    productivity_bonus = 1 + best_productivity * building.module_inventory_size
                    speed_bonus = 1 + best_prod_module.module_effects.speed.bonus * building.module_inventory_size
                    log("speed bonus before beacon: " .. speed_bonus)
                    if beacon_slots then
                        speed_bonus = speed_bonus + (best_speed_module.module_effects.speed.bonus * beacon_slots / 2)
                        log("speed bonus after beacon: " .. speed_bonus)
                    end
                elseif best_speed_module ~= nil then
                    speed_bonus = 1 + best_speed_module.module_effects.speed.bonus * building.module_inventory_size
                    log("speed bonus before beacon: " .. speed_bonus)
                    if beacon_slots then
                        speed_bonus = speed_bonus + (best_speed_module.module_effects.speed.bonus * beacon_slots / 2)
                        log("speed bonus after beacon: " .. speed_bonus)
                    end
                end

                local items_per_second_per_building = productivity_bonus * main_product.amount / r.energy
                local n_buildings = math.ceil(recipe_summary.ips / (speed_bonus * building.crafting_speed * items_per_second_per_building))
                recipes_buildings[rec_name] = { n_buildings = n_buildings, building = building.name,
                                                items_per_second = recipe_summary.ips }
            end
        end

        -- persist results in global table
        global.players[player.index].recipes_buildings = recipes_buildings
        global.players[player.index].byproducts = byproducts
        global.players[player.index].raw_resources = raw_resources_per_second


        -- draw results
        draw_results(player.index)
    end
end)


