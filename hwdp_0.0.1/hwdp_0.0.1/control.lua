---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by obygi.
--- DateTime: 24.05.2024 00:39
---
---
---
require("lib_traverse")
require("lib_gui")

BUILDING_NOT_RESEARCHED = "building not researched, you fag!"

local function check_if_entity_prototype_maps_to_recipe(name)
    return not string.find(name, "-grounded") and not string.find(name, "-spaced")
end

local function initialize_global(player)
    global.players[player.index] = {}
    global.players[player.index].controls_active = true
    global.players[player.index].selected_ips = nil
    global.players[player.index].selected_recipe = nil
    global.players[player.index].recipes_buildings = nil
    global.players[player.index].byproducts = nil
    global.players[player.index].raw_resources = nil
end

script.on_init(function()
    global.players = {}
    for _, player in pairs(game.players) do
        initialize_global(player)
    end
end)

script.on_event(defines.events.on_player_created, function(event)
    local player = game.get_player(event.player_index)
    initialize_global(player)
end)

script.on_event(defines.events.on_player_removed, function(event)
    global.players[event.player_index] = nil
end)

script.on_event("toggle_interface", function(event)
    local player = game.get_player(event.player_index)
    toggle_interface(player)
end)

script.on_event(defines.events.on_gui_closed, function(event)
    if event.element and event.element.name == "main_frame" then
        local player = game.get_player(event.player_index)
        toggle_interface(player)
    end
end)

script.on_event(defines.events.on_gui_click, function(event)
    if event.element.name == "run_recipes" then
        local player = game.get_player(event.player_index)
        local controls_flow = player.gui.screen.main_frame.content_frame.controls_flow
        local recipe_name = controls_flow.choose_recipe.elem_value
        local recipe_ips = controls_flow.ips_textfield.text

        -- persist search in global table and clear results
        global.players[player.index].selected_recipe = recipe_name
        global.players[player.index].selected_ips = recipe_ips
        global.players[player.index].recipes_buildings = nil
        global.players[player.index].byproducts = nil
        global.players[player.index].raw_resources = nil

        local raw_resources_per_second = {}
        local recipes_summary = {}
        local recipes_buildings = {}
        local byproducts = {}

        -- now retrieve recipe
        local recipe = player.force.recipes[recipe_name]
        traverse(
                player.force.recipes,
                recipe,
                recipe_ips,
                recipes_summary,
                raw_resources_per_second,
                byproducts,
                0,
                1
        )

        -- get building type per crafting category
        local crafting_category_building_map = {}
        for _, recipe_summary in pairs(recipes_summary) do
            local crafting_category = recipe_summary["crafting_category"]
            if crafting_category_building_map[crafting_category] == nil then
                local max_building_speed = -1
                for _, entity in pairs(game.get_filtered_entity_prototypes { { filter = "crafting-category", crafting_category = crafting_category } }) do
                    if check_if_entity_prototype_maps_to_recipe(entity.name) and player.force.recipes[entity.name].enabled == true and entity.crafting_speed > max_building_speed then
                        max_building_speed = entity.crafting_speed
                        crafting_category_building_map[crafting_category] = entity
                    end
                end
            end
        end

        -- get recipes for productivity module
        local productivity_recipes = {}
        for _, rec_name in pairs(game.item_prototypes["productivity-module"].limitations) do
            productivity_recipes[rec_name] = true
        end

        -- get the highest unlocked modules
        local best_prod_module
        local best_productivity = 0
        local best_speed_module
        local best_speed_bonus = 0
        for _, rec in pairs(game.get_filtered_recipe_prototypes { { filter = "enabled" }, { filter = "subgroup", subgroup = "module", mode = "and" } }) do
            local module = game.item_prototypes[rec.name]
            local prod_bonus = module.module_effects.productivity.bonus
            local speed_bonus = module.module_effects.speed.bonus
            if string.find(rec.name, "productivity") and prod_bonus > best_productivity then
                best_productivity = prod_bonus
                best_prod_module = module
            end
            if string.find(rec.name, "speed") and speed_bonus > best_speed_bonus then
                best_speed_bonus = speed_bonus
                best_speed_module = module
            end
        end

        -- get number of buildings
        for rec_name, recipe_summary in pairs(recipes_summary) do
            -- building can be nil if it hasn't been unlocked yet
            local building = crafting_category_building_map[recipe_summary.crafting_category]

            if building == nil then
                -- building not researched yet
                recipes_buildings[rec_name] = { n_buildings = 0, building = BUILDING_NOT_RESEARCHED,
                                                items_per_second = recipe_summary.ips }
            else
                -- calculate how many buildings are needed to produce that recipe at required throughput
                local r = game.recipe_prototypes[rec_name]
                local main_product = get_main_product(r)
                local productivity_bonus = 1
                local speed_bonus = 1

                if productivity_recipes[rec_name] ~= nil and best_prod_module ~= nil then
                    -- possible to use productivity modules
                    productivity_bonus = 1 + best_productivity * building.module_inventory_size
                    speed_bonus = 1 + best_prod_module.module_effects.speed.bonus * building.module_inventory_size
                elseif best_speed_module ~= nil then
                    speed_bonus = 1 + best_speed_module.module_effects.speed.bonus * building.module_inventory_size
                end

                local items_per_second_per_building = productivity_bonus * main_product.amount / r.energy
                local n_buildings = math.ceil(recipe_summary.ips / (speed_bonus * building.crafting_speed * items_per_second_per_building))
                recipes_buildings[rec_name] = { n_buildings = n_buildings, building = building.name,
                                                items_per_second = recipe_summary.ips }
            end
        end

        -- persist results in global table
        global.players[player.index].recipes_buildings = recipes_buildings
        global.players[player.index].byproducts = byproducts
        global.players[player.index].raw_resources = raw_resources_per_second


        -- draw results
        draw_results(player.index)
    end
end)


